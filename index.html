<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 포커스 모니터 Ver 2.06</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #111827; color: #f3f4f6; }
        .camera-card { background-color: #1f2937; border: 2px solid #374151; transition: border-color 0.3s ease-in-out, max-width 0.3s ease-in-out; }
        .camera-card.alert { border-color: #ef4444; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } }
        .overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .control-group { background-color: #374151; padding: 0.75rem; border-radius: 0.5rem; }
        .control-group label { font-weight: 500; }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto max-w-[1920px] p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white tracking-tight">
                실시간 포커스 모니터 <span id="version-title" class="text-base align-middle text-gray-400">Ver 2.06</span>
            </h1>
            <p id="status-container" class="text-lg text-yellow-400 mt-2 flex items-center justify-center gap-2">
                <svg id="loading-spinner" class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="status-text">초기화 시작...</span>
            </p>
        </header>

        <div class="bg-gray-800 p-4 rounded-xl shadow-lg mb-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div class="control-group space-y-3">
                <p class="font-bold text-white">초점 기준</p>
                <div class="flex items-center gap-2">
                    <input id="auto-threshold-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="auto-threshold-checkbox">자동 기준 사용</label>
                </div>
                <div id="manual-threshold-group" class="space-y-2">
                    <label for="threshold-slider">수동 기준 점수:</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="threshold-slider" min="10" max="150" value="40" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="threshold-input" min="10" max="150" value="40" class="font-bold text-lg w-20 text-center bg-gray-700 rounded-md border-gray-600">
                    </div>
                </div>
                 <div id="auto-threshold-group" class="space-y-2 hidden">
                    <label for="sensitivity-slider">자동 기준 민감도:</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="sensitivity-slider" min="50" max="95" value="75" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="sensitivity-input" min="50" max="95" value="75" class="font-bold text-lg w-20 text-center bg-gray-700 rounded-md border-gray-600">
                         <span class="text-lg">%</span>
                    </div>
                </div>
            </div>
            <div class="control-group space-y-3">
                <p class="font-bold text-white">출력 크기</p>
                <div class="flex flex-wrap gap-x-4 gap-y-2">
                    <div class="flex items-center"><input type="radio" id="size-auto" name="output-size" value="auto" class="h-4 w-4" checked><label for="size-auto" class="ml-2">자동</label></div>
                    <div class="flex items-center"><input type="radio" id="size-480" name="output-size" value="480p" class="h-4 w-4"><label for="size-480" class="ml-2">480p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-720" name="output-size" value="720p" class="h-4 w-4"><label for="size-720" class="ml-2">720p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-1080" name="output-size" value="1080p" class="h-4 w-4"><label for="size-1080" class="ml-2">1080p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-custom" name="output-size" value="custom" class="h-4 w-4"><label for="size-custom" class="ml-2">지정:</label></div>
                </div>
                <input type="number" id="custom-size-input" placeholder="너비(px)" class="w-full p-2 bg-gray-700 rounded-md border-gray-600" disabled>
            </div>
            <div class="control-group space-y-3">
                 <p class="font-bold text-white">기록 관리</p>
                 <select id="session-select" class="w-full p-2 bg-gray-700 rounded-md border-gray-600">
                     <option value="">세션 기록 선택...</option>
                 </select>
                 <button id="clear-all-logs-button" class="w-full px-3 py-2 bg-red-800 text-white text-sm rounded-md hover:bg-red-700">모든 기록 지우기</button>
            </div>
            <div class="control-group space-y-3">
                <p class="font-bold text-white">기타 설정</p>
                <div class="flex items-center gap-2"><input id="mute-checkbox" type="checkbox" class="h-4 w-4 rounded"><label for="mute-checkbox">음소거</label></div>
                <div class="flex items-center gap-2"><input id="debug-mode-checkbox" type="checkbox" class="h-4 w-4 rounded" checked><label for="debug-mode-checkbox">상세 로그 보기</label></div>
            </div>
        </div>
        
        <div class="flex justify-center my-4">
             <button id="open-camera-select-button" class="bg-blue-600 text-white font-bold py-3 px-8 text-lg rounded-full hover:bg-blue-700 transition disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>모니터링 시작</button>
        </div>
        
        <div id="camera-grid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6"></div>

        <div id="blur-log-panel" class="mt-8 bg-gray-800 p-4 rounded-xl shadow-lg hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 id="blur-log-title" class="text-white font-bold text-lg">흐림 감지 로그</h3>
                <button id="clear-log-button" class="px-3 py-1 bg-red-600 text-white text-sm rounded-md hover:bg-red-700">현재 로그 지우기</button>
            </div>
            <div id="blur-log-container" class="space-y-6 max-h-[80vh] overflow-y-auto pr-2">
            </div>
        </div>

        <div id="debug-panel" class="mt-8 bg-gray-900 text-gray-400 p-4 rounded-lg">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-white font-bold text-lg">상세 분석 로그</h3>
                <button id="clear-debug-log-button" class="px-3 py-1 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-500">로그 지우기</button>
            </div>
            <div id="debug-log-container" class="font-mono text-xs space-y-2 max-h-60 overflow-y-auto bg-black p-2 rounded-md">
            </div>
        </div>
    </div>
    
    <div id="camera-select-modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="fixed inset-0 bg-black bg-opacity-75"></div>
        <div class="relative bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-lg m-4">
            <h3 class="text-lg font-bold mb-4 text-white">모니터링할 카메라 선택</h3>
            <div id="camera-list" class="space-y-2 max-h-64 overflow-y-auto pr-2 mb-6"></div>
            <div class="flex justify-end gap-4">
                <button id="modal-cancel-button" class="px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-500">취소</button>
                <button id="modal-start-button" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">선택 완료</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { FaceDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/+esm";

        // --- DOM Elements ---
        const openCameraSelectButton = document.getElementById('open-camera-select-button');
        const statusContainer = document.getElementById('status-container');
        const statusText = document.getElementById('status-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const cameraGrid = document.getElementById('camera-grid');
        const autoThresholdCheckbox = document.getElementById('auto-threshold-checkbox');
        const manualThresholdGroup = document.getElementById('manual-threshold-group');
        const autoThresholdGroup = document.getElementById('auto-threshold-group');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdInput = document.getElementById('threshold-input');
        const sensitivitySlider = document.getElementById('sensitivity-slider');
        const sensitivityInput = document.getElementById('sensitivity-input');
        const sizeRadios = document.querySelectorAll('input[name="output-size"]');
        const customSizeInput = document.getElementById('custom-size-input');
        const sessionSelect = document.getElementById('session-select');
        const clearAllLogsButton = document.getElementById('clear-all-logs-button');
        const muteCheckbox = document.getElementById('mute-checkbox');
        const debugModeCheckbox = document.getElementById('debug-mode-checkbox');
        const cameraSelectModal = document.getElementById('camera-select-modal');
        const cameraListContainer = document.getElementById('camera-list');
        const modalCancelButton = document.getElementById('modal-cancel-button');
        const modalStartButton = document.getElementById('modal-start-button');
        const blurLogPanel = document.getElementById('blur-log-panel');
        const blurLogTitle = document.getElementById('blur-log-title');
        const blurLogContainer = document.getElementById('blur-log-container');
        const clearLogButton = document.getElementById('clear-log-button');
        const debugPanel = document.getElementById('debug-panel');
        const debugLogContainer = document.getElementById('debug-log-container');
        const clearDebugLogButton = document.getElementById('clear-debug-log-button');

        // --- Constants ---
        const ALERT_SOUND_NOTE = "C5";
        const ALERT_SOUND_DURATION = "8n";
        const MOTION_THRESHOLD = 5.0;
        const ALERT_COOLDOWN = 1000;
        const MAX_DEBUG_LOGS = 100;
        const DB_NAME = 'FocusMonitorDB';
        const DB_VERSION = 1;
        const LOG_STORE_NAME = 'blurLogs';
        const SESSION_STORE_NAME = 'sessions';

        // --- State Variables ---
        let faceDetector;
        const analysisLoops = new Map();
        let audioContextStarted = false;
        let activeStreams = [];
        const cameraAnalysisData = new Map();
        let currentSessionId = null;
        let db;
        const debugLogEntries = [];
        let userHasScrolledDebug = false;

        // --- Debug Logging ---
        function addDebugLog(message, level = 'INFO', data = null) {
            const logEntry = {
                timestamp: new Date().toLocaleTimeString(),
                level,
                message,
                data: data ? JSON.stringify(data) : null
            };
            debugLogEntries.push(logEntry);
            if (debugLogEntries.length > MAX_DEBUG_LOGS) {
                debugLogEntries.shift();
            }
            renderDebugLog();
        }

        function renderDebugLog() {
            debugLogContainer.innerHTML = '';
            debugLogEntries.forEach(log => {
                let colorClass = 'text-gray-400';
                if (log.level === 'SUCCESS') colorClass = 'text-green-400';
                if (log.level === 'ERROR') colorClass = 'text-red-400';
                if (log.level === 'WARN') colorClass = 'text-yellow-400';

                const pre = document.createElement('pre');
                pre.className = `p-1 rounded ${colorClass}`;
                pre.textContent = `[${log.timestamp}][${log.level}] ${log.message}`;
                if(log.data) {
                    pre.textContent += `\n  Data: ${log.data}`;
                }
                debugLogContainer.prepend(pre);
            });

            if (!userHasScrolledDebug) {
                debugLogContainer.scrollTop = 0;
            }
        }
        
        // --- Audio Setup ---
        const synth = new Tone.Synth().toDestination();
        function playAlertSound() {
            if (muteCheckbox.checked) return;
            if (!audioContextStarted) { 
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                audioContextStarted = true; 
            }
            synth.triggerAttackRelease(ALERT_SOUND_NOTE, ALERT_SOUND_DURATION);
        }
        
        // --- IndexedDB Functions ---
        async function initDB() {
            addDebugLog('Initializing IndexedDB...');
            if (!window.idb) {
                addDebugLog('IndexedDB library (idb) is not loaded.', 'ERROR');
                return;
            }
            db = await idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db) {
                    addDebugLog(`Upgrading DB to version ${DB_VERSION}...`, 'WARN');
                    if (!db.objectStoreNames.contains(SESSION_STORE_NAME)) {
                        db.createObjectStore(SESSION_STORE_NAME, { keyPath: 'id' });
                        addDebugLog(`Object store '${SESSION_STORE_NAME}' created.`, 'SUCCESS');
                    }
                    if (!db.objectStoreNames.contains(LOG_STORE_NAME)) {
                        const logStore = db.createObjectStore(LOG_STORE_NAME, { autoIncrement: true });
                        logStore.createIndex('sessionId', 'sessionId', { unique: false });
                        addDebugLog(`Object store '${LOG_STORE_NAME}' created.`, 'SUCCESS');
                    }
                },
            });
            addDebugLog('IndexedDB initialized successfully.', 'SUCCESS');
        }

        async function createSession() {
            if (!db) return;
            currentSessionId = Date.now();
            const tx = db.transaction(SESSION_STORE_NAME, 'readwrite');
            await tx.store.add({ id: currentSessionId, startTime: new Date().toLocaleString() });
            await tx.done;
            await loadSessions();
            sessionSelect.value = currentSessionId;
            return currentSessionId;
        }

        async function saveBlurLog(logEntry) {
            if (!db || !currentSessionId) return;
            logEntry.sessionId = currentSessionId;
            const tx = db.transaction(LOG_STORE_NAME, 'readwrite');
            await tx.store.add(logEntry);
            await tx.done;
        }

        async function getLogsForSession(sessionId) {
            if (!db) return [];
            const tx = db.transaction(LOG_STORE_NAME, 'readonly');
            const index = tx.store.index('sessionId');
            const logs = await index.getAll(IDBKeyRange.only(Number(sessionId)));
            await tx.done;
            return logs;
        }

        async function loadSessions() {
            if (!db) return;
            const tx = db.transaction(SESSION_STORE_NAME, 'readonly');
            const sessions = await tx.store.getAll();
            await tx.done;
            sessionSelect.innerHTML = '<option value="">세션 기록 선택...</option>';
            sessions.sort((a, b) => b.id - a.id).forEach(session => {
                const option = document.createElement('option');
                option.value = session.id;
                option.textContent = session.startTime;
                sessionSelect.appendChild(option);
            });
        }

        async function clearAllData() {
            if (!db) return;
            const confirmed = confirm('정말로 모든 세션과 로그 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.');
            if (confirmed) {
                const tx = db.transaction([SESSION_STORE_NAME, LOG_STORE_NAME], 'readwrite');
                await tx.objectStore(SESSION_STORE_NAME).clear();
                await tx.objectStore(LOG_STORE_NAME).clear();
                await tx.done;
                await loadSessions();
                renderBlurLog([]);
                addDebugLog('All data has been cleared.', 'WARN');
            }
        }

        // --- Core Logic ---
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData;
            if (width === 0 || height === 0) return 0;
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                gray[i / 4] = 0.299 * r + 0.587 * g + 0.114 * b;
            }
            const laplacianValues = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;
                    const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                    laplacianValues.push(laplacian);
                }
            }
            if (laplacianValues.length === 0) return 0;
            const mean = laplacianValues.reduce((acc, val) => acc + val, 0) / laplacianValues.length;
            const variance = laplacianValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / laplacianValues.length;
            return variance;
        }
        
        function getCentermostFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null;
            if (detections.length === 1) return detections[0];
            
            const frameCenterX = videoWidth / 2;
            const frameCenterY = videoHeight / 2;
            let centermostFace = null;
            let minDistance = Infinity;

            for (const detection of detections) {
                const box = detection.boundingBox;
                if (!box) continue;
                const faceCenterX = box.originX + box.width / 2;
                const faceCenterY = box.originY + box.height / 2;
                const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2));
                
                if (distance < minDistance) {
                    minDistance = distance;
                    centermostFace = detection;
                }
            }
            return centermostFace;
        }

        function renderBlurLog(logEntries) {
            blurLogContainer.innerHTML = '';
            if (logEntries.length > 0) {
                blurLogPanel.classList.remove('hidden');
            } else {
                blurLogPanel.classList.add('hidden');
            }

            [...logEntries].reverse().forEach(entry => {
                const logItem = document.createElement('div');
                logItem.className = 'bg-gray-700 p-3 rounded-lg';

                const header = document.createElement('div');
                header.className = 'text-center mb-2 text-sm';
                const timeEl = document.createElement('p');
                timeEl.className = 'text-gray-300';
                timeEl.textContent = `감지 시간: ${entry.timestamp}`;
                header.appendChild(timeEl);

                const framesContainer = document.createElement('div');
                framesContainer.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
                
                const createFrame = (title, color, dataUrl, score) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'text-center';
                    const p = document.createElement('p');
                    p.className = `font-semibold mb-1 ${color}`;
                    p.textContent = title;
                    const pScore = document.createElement('p');
                    pScore.className = 'font-mono text-xs text-gray-400 -mt-1 mb-2';
                    pScore.textContent = `(점수: ${score})`;
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'w-full rounded-lg bg-black';
                    
                    wrapper.appendChild(p);
                    wrapper.appendChild(pScore);
                    wrapper.appendChild(canvas);
                    
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        canvas.getContext('2d').drawImage(img, 0, 0);
                    };
                    img.src = dataUrl;
                    return wrapper;
                };

                if (entry.clearFrameUrl) {
                    framesContainer.appendChild(createFrame('이전 프레임 (선명)', 'text-green-400', entry.clearFrameUrl, entry.clearScore.toFixed(1)));
                }
                framesContainer.appendChild(createFrame('현재 프레임 (흐림)', 'text-red-400', entry.blurryFrameUrl, entry.blurryScore.toFixed(1)));

                logItem.appendChild(header);
                logItem.appendChild(framesContainer);
                blurLogContainer.appendChild(logItem);
            });
        }
        
        async function startAnalysisLoop(videoElement, processCanvas, overlayCanvas, scoreElement, deviceId, isPrimaryDebugTarget) {
            const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });
            let alertState = { active: false, lastAlertTime: 0 };
            const analysisData = cameraAnalysisData.get(deviceId);
            let lastClearFrame = { url: null, score: 0 };
            const frameCaptureCanvas = document.createElement('canvas');

            let lastTime = -1;
            async function loop(currentTime) {
                if (!analysisLoops.has(deviceId)) return; // 루프 중지 플래그 확인

                if (lastTime === -1) {
                    lastTime = currentTime;
                }
                
                try {
                    if (!videoElement.srcObject || !videoElement.srcObject.active || videoElement.paused || videoElement.videoWidth === 0) {
                        analysisLoops.delete(deviceId);
                        return;
                    }
                    
                    const detectionsResult = faceDetector.detectForVideo(videoElement, currentTime);
                    const detections = detectionsResult.detections;
                    
                    const overlayCtx = overlayCanvas.getContext('2d');
                    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    
                    if (detections.length > 0) {
                        const mainFaceForAnalysis = getCentermostFace(detections, videoElement.videoWidth, videoElement.videoHeight);
                        if (!mainFaceForAnalysis) {
                            analysisData.lastPosition = null;
                            requestAnimationFrame(loop);
                            return;
                        }

                        const mainFaceIndex = detections.findIndex(d => d === mainFaceForAnalysis);
                        const mainFaceRawBox = mainFaceForAnalysis.boundingBox;
                        processCtx.drawImage(videoElement, 0, 0, processCanvas.width, processCanvas.height);
                        
                        const clampedX = Math.max(0, mainFaceRawBox.originX);
                        const clampedY = Math.max(0, mainFaceRawBox.originY);
                        const clampedWidth = Math.min(processCanvas.width - clampedX, mainFaceRawBox.width);
                        const clampedHeight = Math.min(processCanvas.height - clampedY, mainFaceRawBox.height);
                        const faceImageData = processCtx.getImageData(clampedX, clampedY, clampedWidth, clampedHeight);

                        const score = calculateFocusScore(faceImageData);
                        
                        const currentCenter = { x: mainFaceRawBox.originX + mainFaceRawBox.width / 2, y: mainFaceRawBox.originY + mainFaceRawBox.height / 2 };
                        let movementDistance = 0;
                        if (analysisData.lastPosition) {
                            const dx = currentCenter.x - analysisData.lastPosition.x;
                            const dy = currentCenter.y - analysisData.lastPosition.y;
                            movementDistance = Math.sqrt(dx * dx + dy * dy);
                        }
                        analysisData.lastPosition = currentCenter;
                        
                        const isStationary = movementDistance < MOTION_THRESHOLD;
                        let isScoreLow, isBlurry;

                        if(autoThresholdCheckbox.checked) {
                            analysisData.scores.push(score);
                            if (analysisData.scores.length > 50) analysisData.scores.shift();
                            
                            if (analysisData.scores.length > 30) {
                                const sum = analysisData.scores.reduce((a, b) => a + b, 0);
                                analysisData.average = sum / analysisData.scores.length;
                                const sensitivity = parseFloat(sensitivityInput.value) / 100;
                                const dynamicThreshold = analysisData.average * sensitivity;
                                isScoreLow = score < dynamicThreshold;
                                scoreElement.textContent = `${score.toFixed(1)} / ${analysisData.average.toFixed(1)}`;
                            } else {
                                isScoreLow = false;
                                scoreElement.textContent = score.toFixed(1);
                            }
                        } else {
                            const threshold = parseFloat(thresholdInput.value);
                            isScoreLow = score < threshold;
                            scoreElement.textContent = score.toFixed(1);
                        }
                        
                        isBlurry = isScoreLow && isStationary;
                        
                        if (isBlurry) {
                            scoreElement.classList.add('text-red-500');
                            const now = Date.now();
                            if (!alertState.active && (now - alertState.lastAlertTime > ALERT_COOLDOWN)) {
                                alertState.active = true;
                                alertState.lastAlertTime = now;
                                videoElement.parentElement.parentElement.classList.add('alert');
                                playAlertSound();

                                if (isPrimaryDebugTarget) {
                                    frameCaptureCanvas.width = videoElement.videoWidth;
                                    frameCaptureCanvas.height = videoElement.videoHeight;
                                    const frameCtx = frameCaptureCanvas.getContext('2d');
                                    frameCtx.drawImage(videoElement, 0, 0);
                                    detections.forEach((d, i) => {
                                        const box = d.boundingBox;
                                        if(box) {
                                            frameCtx.strokeStyle = (i === mainFaceIndex && isBlurry) ? 'red' : '#3b82f6';
                                            frameCtx.lineWidth = (i === mainFaceIndex && isBlurry) ? 4 : 2;
                                            frameCtx.strokeRect(box.originX, box.originY, box.width, box.height);
                                        }
                                    });
                                    const blurryFrameDataUrl = frameCaptureCanvas.toDataURL('image/jpeg');

                                    const logEntry = {
                                        timestamp: new Date().toLocaleTimeString(),
                                        clearFrameUrl: lastClearFrame.url,
                                        blurryFrameUrl: blurryFrameDataUrl,
                                        clearScore: lastClearFrame.score,
                                        blurryScore: score
                                    };
                                    saveBlurLog(logEntry);
                                    if(String(sessionSelect.value) === String(currentSessionId)){
                                        getLogsForSession(currentSessionId).then(renderBlurLog);
                                    }
                                }
                            }
                        } else {
                            scoreElement.classList.remove('text-red-500');
                            if(alertState.active) {
                                videoElement.parentElement.parentElement.classList.remove('alert');
                                alertState.active = false;
                            }
                            
                            if (!isScoreLow) {
                                frameCaptureCanvas.width = videoElement.videoWidth;
                                frameCaptureCanvas.height = videoElement.videoHeight;
                                const frameCtx = frameCaptureCanvas.getContext('2d');
                                frameCtx.drawImage(videoElement, 0, 0);
                                detections.forEach((d, i) => {
                                    const box = d.boundingBox;
                                    if(box) {
                                        frameCtx.strokeStyle = (i === mainFaceIndex) ? '#3b82f6' : '#888888';
                                        frameCtx.lineWidth = (i === mainFaceIndex) ? 4 : 2;
                                        frameCtx.strokeRect(box.originX, box.originY, box.width, box.height);
                                    }
                                });
                                lastClearFrame.url = frameCaptureCanvas.toDataURL('image/jpeg');
                                lastClearFrame.score = score;
                            }
                        }

                        detections.forEach((detection, index) => {
                            const currentBox = detection.boundingBox;
                            if (!currentBox) return;
                            const isMainFace = index === mainFaceIndex;
                            overlayCtx.strokeStyle = (isMainFace && isBlurry) ? 'red' : '#3b82f6';
                            overlayCtx.lineWidth = (isMainFace && isBlurry) ? 4 : 2;
                            overlayCtx.strokeRect(currentBox.originX, currentBox.originY, currentBox.width, currentBox.height);
                        });
                        
                        const isDebugMode = debugModeCheckbox.checked && isPrimaryDebugTarget;
                        if (isDebugMode) {
                            // ... 디버그 로그 로직 ...
                        }
                    } else {
                        scoreElement.textContent = '얼굴 미검출';
                        analysisData.lastPosition = null;
                    }
                    if (analysisLoops.has(deviceId)) {
                        requestAnimationFrame(loop);
                    }
                } catch(error) {
                    console.error("Analysis loop error:", error);
                    if (analysisLoops.has(deviceId)) {
                        requestAnimationFrame(loop);
                    }
                }
            }
            analysisLoops.set(deviceId, requestAnimationFrame(loop));
        }

        function stopAllMonitoring() {
            addDebugLog('Stopping all monitoring...', 'WARN');
            activeStreams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
                addDebugLog(`Stream track stopped: ${track.label}`, 'INFO');
            });
            activeStreams = [];
            
            analysisLoops.forEach((loopId, id) => {
                cancelAnimationFrame(loopId);
                addDebugLog(`Analysis loop canceled for device: ${id}`, 'INFO');
            });
            analysisLoops.clear();
            
            cameraAnalysisData.clear();
            cameraGrid.innerHTML = '';
            debugPanel.classList.add('hidden');
            blurLogPanel.classList.add('hidden');
            blurLogContainer.innerHTML = '';
            statusText.textContent = '모니터링이 중지되었습니다. 다시 시작하려면 버튼을 누르세요.';
            statusContainer.classList.remove('text-green-400');
            statusContainer.classList.add('text-yellow-400');
            openCameraSelectButton.textContent = '모니터링 시작';
            currentSessionId = null;
            addDebugLog('All monitoring stopped successfully.', 'SUCCESS');
        }

        async function openCameraSelectionModal() {
            addDebugLog('Opening camera selection modal...');
            stopAllMonitoring();
            openCameraSelectButton.disabled = true;
            try {
                addDebugLog('Requesting user media for device enumeration...');
                const initialStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                initialStream.getTracks().forEach(track => track.stop());
                addDebugLog('Permission granted. Enumerating devices...');
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                addDebugLog(`Found ${videoDevices.length} video devices.`, 'INFO', videoDevices.map(d=>d.label));
                cameraListContainer.innerHTML = '';

                if (videoDevices.length === 0) {
                    cameraListContainer.innerHTML = '<p class="text-gray-400">사용 가능한 카메라가 없습니다.</p>';
                } else {
                    videoDevices.forEach((device, index) => {
                        const label = document.createElement('label');
                        label.className = 'flex items-center gap-3 p-2 rounded-md hover:bg-gray-700 cursor-pointer';
                        label.innerHTML = `<input type="checkbox" value="${device.deviceId}" class="h-4 w-4 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-500"><span class="text-gray-300">${device.label || `카메라 ${index + 1}`}</span>`;
                        cameraListContainer.appendChild(label);
                    });
                }
                cameraSelectModal.style.display = 'flex';
                addDebugLog('Camera selection modal displayed.', 'SUCCESS');
            } catch (err) { 
                statusText.textContent = `카메라 접근 오류: ${err.message}`; 
                addDebugLog('Failed to access camera for enumeration.', 'ERROR', err);
            } finally { 
                openCameraSelectButton.disabled = false; 
            }
        }
        
        async function startSelectedMonitoring() {
            addDebugLog('Start monitoring button clicked.');
            await createSession();
            cameraSelectModal.style.display = 'none';
            const selectedCheckboxes = cameraListContainer.querySelectorAll('input[type="checkbox"]:checked');
            const selectedDeviceIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            addDebugLog(`Selected ${selectedDeviceIds.length} cameras.`, 'INFO', selectedDeviceIds);

            if (selectedDeviceIds.length === 0) { 
                statusText.textContent = '선택된 카메라가 없습니다.'; 
                addDebugLog('No cameras selected.', 'WARN');
                return; 
            }
            
            if (debugModeCheckbox.checked) {
                debugPanel.classList.remove('hidden');
            }

            openCameraSelectButton.textContent = '모니터링 중지';
            cameraGrid.innerHTML = '';
            statusText.textContent = `${selectedDeviceIds.length}개의 카메라를 모니터링합니다.`;
            statusContainer.classList.remove('text-yellow-400');
            statusContainer.classList.add('text-green-400');

            for (let i = 0; i < selectedDeviceIds.length; i++) {
                const deviceId = selectedDeviceIds[i];
                addDebugLog(`Processing device ${i + 1}: ${deviceId}`);
                
                cameraAnalysisData.set(deviceId, { scores: [], average: 0, lastPosition: null });

                const wrapper = document.createElement('div');
                wrapper.className = 'camera-card rounded-lg p-4 flex flex-col gap-2';
                
                const videoContainer = document.createElement('div');
                videoContainer.className = 'relative w-full aspect-video';
                
                const video = document.createElement('video');
                video.autoplay = true; video.muted = true; video.playsInline = true;
                video.className = 'w-full h-full rounded-md bg-black';
                
                const overlayCanvas = document.createElement('canvas');
                overlayCanvas.className = 'overlay-canvas';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'absolute top-0 left-0 w-full p-2 text-xs text-white bg-black bg-opacity-50 flex justify-between';
                const nameEl = document.createElement('span');
                const resolutionEl = document.createElement('span');
                infoDiv.appendChild(nameEl);
                infoDiv.appendChild(resolutionEl);

                const scoreEl = document.createElement('p');
                scoreEl.className = 'absolute bottom-2 left-1/2 -translate-x-1/2 font-bold text-2xl text-white bg-black bg-opacity-50 px-2 rounded';
                
                videoContainer.appendChild(video); 
                videoContainer.appendChild(overlayCanvas);
                videoContainer.appendChild(infoDiv);
                videoContainer.appendChild(scoreEl);

                wrapper.appendChild(videoContainer);
                cameraGrid.appendChild(wrapper);

                try {
                    addDebugLog(`Requesting stream for device: ${deviceId}`);
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: deviceId } } });
                    activeStreams.push(stream);
                    video.srcObject = stream;
                    addDebugLog(`Stream acquired for device: ${deviceId}`, 'SUCCESS');
                    
                    const device = (await navigator.mediaDevices.enumerateDevices()).find(d => d.deviceId === deviceId);
                    nameEl.textContent = device.label || `카메라 ${i + 1}`;
                    
                    const processCanvas = document.createElement('canvas');
                    processCanvas.className = 'hidden';
                    wrapper.appendChild(processCanvas);
                    
                    const isPrimaryDebugTarget = (i === 0);

                    video.onplaying = () => { 
                        addDebugLog(`Video started playing for device: ${deviceId}`);
                        processCanvas.width = video.videoWidth;
                        processCanvas.height = video.videoHeight;
                        overlayCanvas.width = video.videoWidth;
                        overlayCanvas.height = video.videoHeight;
                        resolutionEl.textContent = `원본: ${video.videoWidth}x${video.videoHeight}`;

                        startAnalysisLoop(video, processCanvas, overlayCanvas, scoreEl, deviceId, isPrimaryDebugTarget); 
                    };

                } catch (err) {
                    addDebugLog(`Failed to get stream for device: ${deviceId}`, 'ERROR', err);
                    console.error(`카메라 ${deviceId} 열기 실패:`, err.name, err.message);
                    wrapper.classList.add('error');
                    const errorPlaceholder = document.createElement('div');
                    errorPlaceholder.className = 'w-full h-full bg-black rounded-md flex items-center justify-center text-center p-4';
                    errorPlaceholder.innerHTML = `<p class="text-yellow-400">카메라 열기 실패<br><span class="text-sm text-gray-400">${err.name}</span></p>`;
                    videoContainer.replaceChild(errorPlaceholder, video);
                }
            }
            applyOutputSize();
        }

        function applyOutputSize() {
            // ... (생략, 기존과 동일)
        }

        function saveSettings() {
            // ... (생략, 기존과 동일)
        }

        function loadSettings() {
            // ... (생략, 기존과 동일)
        }

        function toggleThresholdControls(){
            // ... (생략, 기존과 동일)
        }

        function toggleCustomSizeInput() {
            // ... (생략, 기존과 동일)
        }

        async function initializeApp() {
            addDebugLog('App initializing...');
            loadSettings();

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusText.textContent = "오류: 이 브라우저에서는 카메라 기능을 지원하지 않습니다.";
                loadingSpinner.style.display = 'none';
                openCameraSelectButton.disabled = true; 
                addDebugLog('Camera API not supported.', 'ERROR');
                return;
            }
            addDebugLog('Camera API supported.', 'SUCCESS');

            try {
                await initDB();
                await loadSessions();
            } catch (error) {
                addDebugLog('Failed to initialize IndexedDB.', 'ERROR', error);
            }

            try {
                statusText.textContent = "핵심 엔진(WASM) 로딩 중...";
                addDebugLog('Loading Vision Wasm...');
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                addDebugLog('Vision Wasm loaded.', 'SUCCESS');
                
                statusText.textContent = "얼굴 인식 AI 모델 다운로드 중...";
                addDebugLog('Creating FaceDetector...');
                faceDetector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO"
                });
                addDebugLog('FaceDetector created.', 'SUCCESS');

                statusText.textContent = '모델 로딩 완료! 모니터링 시작 버튼을 누르세요.';
                loadingSpinner.style.display = 'none';
                statusContainer.classList.remove('text-yellow-400');
                statusContainer.classList.add('text-green-400');
                openCameraSelectButton.disabled = false;
            } catch (error) {
                statusText.textContent = `모델 로딩 실패: ${error.message}`;
                loadingSpinner.style.display = 'none';
                addDebugLog('MediaPipe model loading failed.', 'ERROR', error);
                console.error("MediaPipe model loading failed:", error);
            }
        }
        
        // --- Event Listeners ---
        openCameraSelectButton.addEventListener('click', () => {
             if (Tone.context.state !== 'running') {
                Tone.start();
             }
             if (activeStreams.length > 0) stopAllMonitoring();
             else openCameraSelectionModal();
        });

        modalCancelButton.addEventListener('click', () => { cameraSelectModal.style.display = 'none'; });
        modalStartButton.addEventListener('click', () => {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            startSelectedMonitoring();
        });
        
        thresholdSlider.addEventListener('input', (e) => { thresholdInput.value = e.target.value; saveSettings(); });
        thresholdInput.addEventListener('input', (e) => { thresholdSlider.value = e.target.value; saveSettings(); });
        sensitivitySlider.addEventListener('input', (e) => { sensitivityInput.value = e.target.value; saveSettings(); });
        sensitivityInput.addEventListener('input', (e) => { sensitivitySlider.value = e.target.value; saveSettings(); });
        autoThresholdCheckbox.addEventListener('change', () => { toggleThresholdControls(); saveSettings(); });
        sizeRadios.forEach(radio => radio.addEventListener('change', () => { toggleCustomSizeInput(); applyOutputSize(); saveSettings(); }));
        customSizeInput.addEventListener('input', () => { applyOutputSize(); saveSettings(); });
        muteCheckbox.addEventListener('change', saveSettings);
        debugModeCheckbox.addEventListener('change', () => {
            debugPanel.classList.toggle('hidden', !debugModeCheckbox.checked);
            saveSettings();
        });

        clearLogButton.addEventListener('click', async () => {
            const selectedSessionId = sessionSelect.value;
            if (!selectedSessionId) return;
            const tx = db.transaction(LOG_STORE_NAME, 'readwrite');
            const index = tx.store.index('sessionId');
            let cursor = await index.openCursor(IDBKeyRange.only(Number(selectedSessionId)));
            while(cursor){
                cursor.delete();
                cursor = await cursor.continue();
            }
            await tx.done;
            renderBlurLog([]);
        });
        
        clearDebugLogButton.addEventListener('click', () => {
            debugLogEntries.length = 0;
            renderDebugLog();
        });

        clearAllLogsButton.addEventListener('click', clearAllData);
        sessionSelect.addEventListener('change', async (e) => {
            const sessionId = e.target.value;
            if (sessionId) {
                blurLogTitle.textContent = `흐림 감지 로그 (${new Date(Number(sessionId)).toLocaleString()})`;
                const logs = await getLogsForSession(sessionId);
                renderBlurLog(logs);
            } else {
                blurLogTitle.textContent = '흐림 감지 로그';
                renderBlurLog([]);
            }
        });

        debugLogContainer.addEventListener('scroll', () => {
            if (debugLogContainer.scrollTop > 0) {
                userHasScrolledDebug = true;
            } else {
                userHasScrolledDebug = false;
            }
        });

        initializeApp();
    </script>
</body>
</html>
