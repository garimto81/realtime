<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 포커스 모니터 Ver 2.29 (UI 개선)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #111827; color: #f3f4f6; }
        .camera-card { background-color: #1f2937; border: 2px solid #374151; transition: border-color 0.3s ease-in-out, max-width 0.3s ease-in-out, max-height 0.3s ease-in-out; }
        .camera-card.alert { border-color: #ef4444; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } }
        .overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .control-group { background-color: #374151; padding: 0.75rem; border-radius: 0.5rem; }
        .control-group label { font-weight: 500; }
        .custom-modal-backdrop { display: none; position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.75); z-index: 50; align-items: center; justify-content: center; }
        .custom-modal-content { background-color: #1f2937; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); width: 90%; max-width: 500px; }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto max-w-[1920px] p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white tracking-tight">
                실시간 포커스 모니터 <span id="version-title" class="text-base align-middle text-gray-400">Ver 2.29</span>
            </h1>
            <p id="status-container" class="text-lg text-yellow-400 mt-2 flex items-center justify-center gap-2">
                <svg id="loading-spinner" class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="status-text">초기화 시작...</span>
            </p>
        </header>

        <!-- Controls Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg mb-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <div class="control-group space-y-3">
                <p class="font-bold text-white">초점 기준</p>
                <div class="flex items-center gap-2">
                    <input id="auto-threshold-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="auto-threshold-checkbox">자동 기준 사용</label>
                </div>
                <div id="manual-threshold-group" class="space-y-2">
                    <label for="threshold-slider">수동 기준 점수:</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="threshold-slider" min="10" max="150" value="40" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="threshold-input" min="10" max="150" value="40" class="font-bold text-lg w-20 text-center bg-gray-700 rounded-md border-gray-600">
                    </div>
                </div>
                 <div id="auto-threshold-group" class="space-y-2 hidden">
                    <label for="sensitivity-slider">자동 기준 민감도:</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="sensitivity-slider" min="50" max="95" value="75" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="sensitivity-input" min="50" max="95" value="75" class="font-bold text-lg w-20 text-center bg-gray-700 rounded-md border-gray-600">
                        <span class="text-lg">%</span>
                    </div>
                </div>
            </div>
            <div class="control-group space-y-3" id="history-control-group">
                 <p class="font-bold text-white">기록 관리</p>
                 <select id="session-select" class="w-full p-2 bg-gray-700 rounded-md border-gray-600">
                     <option value="">세션 기록 선택...</option>
                 </select>
                 <button id="clear-all-logs-button" class="w-full px-3 py-2 bg-red-800 text-white text-sm rounded-md hover:bg-red-700 mt-2">모든 기록 지우기</button>
                 <button id="download-log-button" class="w-full px-3 py-2 bg-green-700 text-white text-sm rounded-md hover:bg-green-600 mt-2 hidden">세션 로그 다운로드</button>
            </div>
            <div class="control-group space-y-3">
                <p class="font-bold text-white">기타 설정</p>
                <div class="flex items-center gap-2"><input id="mute-checkbox" type="checkbox" class="h-4 w-4 rounded"><label for="mute-checkbox">음소거</label></div>
                <div class="flex items-center gap-2"><input id="debug-mode-checkbox" type="checkbox" class="h-4 w-4 rounded" checked><label for="debug-mode-checkbox">상세 로그 보기</label></div>
            </div>
        </div>
        
        <div class="flex justify-center my-4">
             <button id="main-action-button" class="bg-blue-600 text-white font-bold py-3 px-8 text-lg rounded-full hover:bg-blue-700 transition disabled:bg-gray-500 disabled:cursor-not-allowed">모니터링 시작</button>
        </div>
        
        <div id="camera-grid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6"></div>

        <div id="blur-log-panel" class="mt-8 bg-gray-800 p-4 rounded-xl shadow-lg hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 id="blur-log-title" class="text-white font-bold text-lg">흐림 감지 로그</h3>
                <button id="clear-log-button" class="px-3 py-1 bg-red-600 text-white text-sm rounded-md hover:bg-red-700">현재 세션 모두 지우기</button>
            </div>
            <div id="blur-log-container" class="space-y-6 max-h-[80vh] overflow-y-auto pr-2">
            </div>
        </div>

        <div id="debug-panel" class="mt-8 bg-gray-900 text-gray-400 p-4 rounded-lg hidden">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-white font-bold text-lg">상세 분석 로그</h3>
                <button id="clear-debug-log-button" class="px-3 py-1 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-500">로그 지우기</button>
            </div>
            <div id="debug-log-container" class="font-mono text-xs space-y-2 max-h-60 overflow-y-auto bg-black p-2 rounded-md">
            </div>
        </div>
    </div>
    
    <div id="camera-select-modal" class="custom-modal-backdrop">
        <div class="custom-modal-content">
            <h3 class="text-lg font-bold mb-4 text-white">모니터링 설정</h3>
            <div class="control-group space-y-3 mb-6">
                <p class="font-bold text-white">1. 출력 크기 선택</p>
                <div id="modal-output-size-controls" class="flex flex-wrap gap-x-4 gap-y-2">
                    <div class="flex items-center"><input type="radio" id="size-auto" name="output-size" value="auto" class="h-4 w-4" checked><label for="size-auto" class="ml-2">자동</label></div>
                    <div class="flex items-center"><input type="radio" id="size-480" name="output-size" value="480" class="h-4 w-4"><label for="size-480" class="ml-2">480p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-720" name="output-size" value="720" class="h-4 w-4"><label for="size-720" class="ml-2">720p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-1080" name="output-size" value="1080" class="h-4 w-4"><label for="size-1080" class="ml-2">1080p</label></div>
                    <div class="flex items-center"><input type="radio" id="size-custom" name="output-size" value="custom" class="h-4 w-4"><label for="size-custom" class="ml-2">너비 지정:</label></div>
                </div>
                <input type="number" id="custom-size-input" placeholder="최대 너비(px)" class="w-full p-2 bg-gray-700 rounded-md border-gray-600" disabled>
            </div>
            <div class="control-group space-y-3">
                <p class="font-bold text-white">2. 카메라 및 해상도 선택</p>
                <div id="camera-list" class="space-y-2 max-h-48 overflow-y-auto pr-2"></div>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="modal-cancel-button" class="px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-500">취소</button>
                <button id="modal-start-button" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">선택 완료</button>
            </div>
        </div>
    </div>

    <div id="custom-confirm-modal" class="custom-modal-backdrop">
        <div class="custom-modal-content">
            <h3 id="confirm-modal-title" class="text-lg font-bold text-white mb-4"></h3>
            <p id="confirm-modal-body" class="text-gray-300 mb-6"></p>
            <div class="flex justify-end gap-4">
                <button id="confirm-modal-cancel" class="px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-500">취소</button>
                <button id="confirm-modal-ok" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">확인</button>
            </div>
        </div>
    </div>

    <div id="image-lightbox-modal" class="custom-modal-backdrop">
        <span id="lightbox-close-button" class="absolute top-4 right-6 text-white text-5xl font-bold cursor-pointer hover:text-gray-300">&times;</span>
        <img id="lightbox-image" class="max-w-[90vw] max-h-[90vh] object-contain rounded-lg shadow-2xl">
    </div>


    <script type="module">
        import { FaceDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/+esm";

        // =================================================================
        //  DATABASE MANAGER MODULE
        // =================================================================
        class DatabaseManager {
            constructor(dbName, dbVersion, storeConfigs) {
                this.db = null;
                this.dbName = dbName;
                this.dbVersion = dbVersion;
                this.storeConfigs = storeConfigs;
            }

            async init() {
                if (!window.idb) {
                    throw new Error('IndexedDB library (idb) is not loaded.');
                }
                this.db = await idb.openDB(this.dbName, this.dbVersion, {
                    upgrade: (db) => {
                        for (const storeName of Object.keys(this.storeConfigs)) {
                            if (!db.objectStoreNames.contains(storeName)) {
                                const config = this.storeConfigs[storeName];
                                const store = db.createObjectStore(storeName, config.options);
                                if (config.indexes) {
                                    config.indexes.forEach(index => store.createIndex(index.name, index.keyPath, index.options));
                                }
                            }
                        }
                    },
                });
                return this.db;
            }

            async add(storeName, data) { return this.db.add(storeName, data); }
            async getAll(storeName) { return this.db.getAll(storeName); }
            async getAllFromIndex(storeName, indexName, query) {
                const results = [];
                let cursor = await this.db.transaction(storeName).store.index(indexName).openCursor(IDBKeyRange.only(query));
                while (cursor) {
                    results.push({ id: cursor.primaryKey, ...cursor.value });
                    cursor = await cursor.continue();
                }
                return results;
            }
            async delete(storeName, key) { return this.db.delete(storeName, key); }
            async clearStore(storeName) { return this.db.clear(storeName); }
            async deleteFromIndex(storeName, indexName, query) {
                const tx = this.db.transaction(storeName, 'readwrite');
                const index = tx.store.index(indexName);
                let cursor = await index.openCursor(IDBKeyRange.only(query));
                while (cursor) {
                    cursor.delete();
                    cursor = await cursor.continue();
                }
                return tx.done;
            }
        }

        // =================================================================
        //  UI MANAGER MODULE
        // =================================================================
        class UIManager {
            constructor() {
                this.dom = {};
                this.bindDOMElements();
            }

            bindDOMElements() {
                const ids = [
                    'main-action-button', 'status-container', 'status-text', 'loading-spinner',
                    'camera-grid', 'auto-threshold-checkbox', 'manual-threshold-group',
                    'auto-threshold-group', 'threshold-slider', 'threshold-input',
                    'sensitivity-slider', 'sensitivity-input', 'custom-size-input',
                    'session-select', 'clear-all-logs-button', 'mute-checkbox',
                    'debug-mode-checkbox', 'camera-select-modal', 'camera-list',
                    'modal-cancel-button', 'modal-start-button', 'blur-log-panel',
                    'blur-log-title', 'blur-log-container', 'clear-log-button', 'debug-panel',
                    'debug-log-container', 'clear-debug-log-button', 'custom-confirm-modal',
                    'confirm-modal-title', 'confirm-modal-body', 'confirm-modal-cancel', 'confirm-modal-ok',
                    'history-control-group', 'download-log-button',
                    'image-lightbox-modal', 'lightbox-close-button', 'lightbox-image',
                    'modal-output-size-controls'
                ];
                ids.forEach(id => {
                    const camelCaseId = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                    this.dom[camelCaseId] = document.getElementById(id);
                });
                this.dom.sizeRadios = document.querySelectorAll('input[name="output-size"]');
            }

            updateStatus(message, type) {
                this.dom.statusText.textContent = message;
                this.dom.loadingSpinner.style.display = type === 'loading' ? 'block' : 'none';
                const container = this.dom.statusContainer;
                container.className = 'text-lg mt-2 flex items-center justify-center gap-2';
                if (type === 'success') container.classList.add('text-green-400');
                else if (type === 'error') container.classList.add('text-red-400');
                else container.classList.add('text-yellow-400');
            }

            setAppState(state) {
                this.dom.mainActionButton.disabled = state === 'initializing';
                if (state === 'stopped') {
                    this.dom.mainActionButton.textContent = '모니터링 시작';
                    this.updateStatus('모니터링할 카메라를 선택하세요.', 'idle');
                } else if (state === 'monitoring') {
                    this.dom.mainActionButton.textContent = '모니터링 중지';
                }
            }
            
            toggleModal(modalId, show) {
                this.dom[modalId].style.display = show ? 'flex' : 'none';
            }

            showConfirm(title, body, onOk) {
                this.dom.confirmModalTitle.textContent = title;
                this.dom.confirmModalBody.textContent = body;
                const newOkButton = this.dom.confirmModalOk.cloneNode(true);
                this.dom.confirmModalOk.parentNode.replaceChild(newOkButton, this.dom.confirmModalOk);
                this.dom.confirmModalOk = newOkButton;
                newOkButton.addEventListener('click', () => {
                    onOk();
                    this.toggleModal('customConfirmModal', false);
                }, { once: true });
                this.toggleModal('customConfirmModal', true);
            }

            disableLoggingFeatures() {
                this.dom.sessionSelect.classList.add('hidden');
                this.dom.clearAllLogsButton.classList.add('hidden');
                this.dom.downloadLogButton.classList.remove('hidden');
                const historyGroup = this.dom.historyControlGroup;
                historyGroup.querySelector('p').textContent = '기록 관리 (저장소 비활성)';
                if (!historyGroup.querySelector('.db-error-message')) {
                    const message = document.createElement('p');
                    message.className = 'text-xs text-yellow-400 mt-1 db-error-message';
                    message.textContent = '로그는 현재 세션에서만 유지되며 다운로드 가능합니다.';
                    historyGroup.appendChild(message);
                }
            }
            
            populateCameraList(devices) {
                this.dom.cameraList.innerHTML = '';
                if (devices.length === 0) {
                    this.dom.cameraList.innerHTML = '<p class="text-gray-400">사용 가능한 카메라가 없습니다.</p>';
                    return;
                }
                devices.forEach((device, index) => {
                    const item = document.createElement('div');
                    item.className = 'flex items-center justify-between p-2 rounded-md hover:bg-gray-700';
                    item.innerHTML = `
                        <label class="flex items-center gap-3 cursor-pointer">
                            <input type="checkbox" data-device-id="${device.deviceId}" class="h-4 w-4 rounded">
                            <span class="text-gray-300">${device.label || `카메라 ${index + 1}`}</span>
                        </label>
                        <select data-res-for="${device.deviceId}" class="bg-gray-600 rounded-md p-1 text-xs text-white">
                            <option value="default">기본값</option>
                            <option value="640x480">640x480</option>
                            <option value="1280x720">1280x720 (HD)</option>
                            <option value="1920x1080">1920x1080 (FHD)</option>
                        </select>
                    `;
                    this.dom.cameraList.appendChild(item);
                });
            }

            createCameraCard() {
                const card = {};
                card.wrapper = document.createElement('div');
                card.wrapper.className = 'camera-card rounded-lg p-4 flex flex-col gap-2';
                card.videoContainer = document.createElement('div');
                card.videoContainer.className = 'relative w-full';
                card.video = document.createElement('video');
                card.video.autoplay = true; card.video.muted = true; card.video.playsInline = true;
                card.video.className = 'w-full h-full rounded-md bg-black';
                card.overlayCanvas = document.createElement('canvas');
                card.overlayCanvas.className = 'overlay-canvas';
                const infoDiv = document.createElement('div');
                infoDiv.className = 'absolute top-0 left-0 w-full p-2 text-xs text-white bg-black bg-opacity-50 flex justify-between items-center flex-wrap gap-x-4';
                card.nameEl = document.createElement('span');
                card.originalResolutionEl = document.createElement('span');
                infoDiv.append(card.nameEl, card.originalResolutionEl);
                card.scoreEl = document.createElement('p');
                card.scoreEl.className = 'absolute bottom-2 left-1/2 -translate-x-1/2 font-bold text-2xl text-white bg-black bg-opacity-50 px-2 rounded';
                card.processCanvas = document.createElement('canvas');
                card.processCanvas.className = 'hidden';

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex justify-center mt-2';
                card.captureButton = document.createElement('button');
                card.captureButton.className = 'manual-capture-button bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded text-sm font-semibold';
                card.captureButton.textContent = '현재 장면 추출';
                actionsDiv.appendChild(card.captureButton);

                card.videoContainer.append(card.video, card.overlayCanvas, infoDiv, card.scoreEl);
                card.wrapper.append(card.videoContainer, actionsDiv, card.processCanvas);
                return card;
            }

            renderBlurLog(logEntries, deleteHandler) {
                this.dom.blurLogContainer.innerHTML = '';
                this.dom.blurLogPanel.classList.toggle('hidden', logEntries.length === 0);
                logEntries.forEach(entry => {
                    const logItem = document.createElement('div');
                    logItem.className = 'bg-gray-700 p-3 rounded-lg relative';
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.innerHTML = '&times;';
                    deleteButton.className = 'absolute top-2 right-2 text-2xl text-gray-400 hover:text-white leading-none p-1';
                    deleteButton.title = '이 로그 삭제';
                    deleteButton.onclick = () => deleteHandler(entry);
                    logItem.appendChild(deleteButton);

                    const createFrame = (title, color, dataUrl, score) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'text-center cursor-pointer';
                        wrapper.innerHTML = `<p class="font-semibold mb-1 ${color}">${title}</p><p class="font-mono text-xs text-gray-400 -mt-1 mb-2">(점수: ${score})</p>`;
                        const canvas = document.createElement('canvas');
                        canvas.className = 'w-full rounded-lg bg-black aspect-video object-contain';
                        wrapper.appendChild(canvas);
                        const img = new Image();
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            canvas.getContext('2d').drawImage(img, 0, 0);
                        };
                        img.src = dataUrl;
                        wrapper.addEventListener('click', () => this.showImageInLightbox(dataUrl));
                        return wrapper;
                    };
                    
                    const isManual = entry.type === 'manual';
                    logItem.insertAdjacentHTML('beforeend', `<div class="text-center mb-2 text-sm"><p class="text-gray-300">${isManual ? '수동 추출' : '흐림 감지'} 시간: ${entry.timestamp}</p></div>`);
                    const framesContainer = document.createElement('div');
                    framesContainer.className = 'grid grid-cols-2 gap-4';
                    
                    if (isManual) {
                        framesContainer.appendChild(createFrame('추출 프레임', 'text-blue-400', entry.blurryFrameUrl, entry.blurryScore.toFixed(1)));
                        framesContainer.appendChild(createFrame('추출 얼굴 (크롭)', 'text-blue-400', entry.croppedBlurryFaceUrl, entry.blurryScore.toFixed(1)));
                    } else {
                        if (entry.clearFrameUrl) {
                            framesContainer.appendChild(createFrame('이전 프레임 (선명)', 'text-green-400', entry.clearFrameUrl, entry.clearScore.toFixed(1)));
                        } else { framesContainer.appendChild(document.createElement('div')); }
                        framesContainer.appendChild(createFrame('현재 프레임 (흐림)', 'text-red-400', entry.blurryFrameUrl, entry.blurryScore.toFixed(1)));
                        if (entry.croppedClearFaceUrl) {
                             framesContainer.appendChild(createFrame('선명한 얼굴 (크롭)', 'text-green-400', entry.croppedClearFaceUrl, entry.clearScore.toFixed(1)));
                        } else { framesContainer.appendChild(document.createElement('div')); }
                        framesContainer.appendChild(createFrame('흐린 얼굴 (크롭)', 'text-red-400', entry.croppedBlurryFaceUrl, entry.blurryScore.toFixed(1)));
                    }
                    logItem.appendChild(framesContainer);
                    this.dom.blurLogContainer.prepend(logItem);
                });
            }

            showImageInLightbox(dataUrl) {
                this.dom.lightboxImage.src = dataUrl;
                this.toggleModal('imageLightboxModal', true);
            }
        }


        // =================================================================
        //  MAIN APPLICATION CLASS
        // =================================================================
        class FocusMonitorApp {
            constructor() {
                this.SETTINGS_KEY = 'focusMonitorSettings';
                this.ui = new UIManager();
                this.dbManager = new DatabaseManager('FocusMonitorDB', 2, {
                    'sessions': { options: { keyPath: 'id' } },
                    'blurLogs': { options: { autoIncrement: true }, indexes: [{ name: 'sessionId', keyPath: 'sessionId', options: { unique: false } }] }
                });
                this.faceDetector = null;
                this.isDbAvailable = false;
                this.currentSessionId = null;
                this.sessionLogEntries = [];
                this.appState = 'initializing';
                this.activeStreams = [];
                this.analysisLoops = new Map();
                this.cameraAnalysisData = new Map();
                this.debugLogEntries = [];
                this.userHasScrolledDebug = false;
                this.audioContextStarted = false;
                this.synth = new Tone.Synth().toDestination();
                this.addEventListeners();
                this.initializeApp();
            }

            async initializeApp() {
                this.addDebugLog('App initializing...');
                this.loadSettings();
                if (!navigator.mediaDevices?.getUserMedia) {
                    this.ui.updateStatus("오류: 이 브라우저에서는 카메라 기능을 지원하지 않습니다.", 'error');
                    this.ui.dom.mainActionButton.disabled = true;
                    return;
                }
                try {
                    await this.dbManager.init();
                    this.isDbAvailable = true;
                    await this.loadSessions();
                } catch (error) {
                    this.isDbAvailable = false;
                    this.addDebugLog('Failed to initialize IndexedDB.', 'ERROR', error);
                    this.ui.disableLoggingFeatures();
                }
                try {
                    this.ui.updateStatus("핵심 엔진(WASM) 로딩 중...", 'loading');
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
                    this.addDebugLog('Vision Wasm loaded.', 'SUCCESS');
                    this.ui.updateStatus("얼굴 인식 AI 모델 다운로드 중...", 'loading');
                    this.faceDetector = await FaceDetector.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite`, delegate: "GPU" },
                        runningMode: "VIDEO"
                    });
                    this.addDebugLog('FaceDetector created.', 'SUCCESS');
                    this.setAppState('stopped');
                } catch (error) {
                    this.ui.updateStatus(`모델 로딩 실패: ${error.message}`, 'error');
                    this.addDebugLog('MediaPipe model loading failed.', 'ERROR', error);
                }
            }
            
            setAppState(newState) {
                this.appState = newState;
                this.ui.setAppState(newState);
            }

            addEventListeners() {
                this.ui.dom.mainActionButton.addEventListener('click', () => this.handleMainAction());
                this.ui.dom.modalCancelButton.addEventListener('click', () => this.ui.toggleModal('cameraSelectModal', false));
                this.ui.dom.modalStartButton.addEventListener('click', () => this.startSelectedMonitoring());
                
                const settingsToSave = ['thresholdSlider', 'thresholdInput', 'sensitivitySlider', 'sensitivityInput', 'autoThresholdCheckbox', 'muteCheckbox', 'debugModeCheckbox'];
                settingsToSave.forEach(id => this.ui.dom[id].addEventListener('change', () => this.saveSettings()));
                
                this.ui.dom.modalOutputSizeControls.addEventListener('change', (e) => {
                    if (e.target.name === 'output-size') {
                        this.ui.dom.customSizeInput.disabled = e.target.value !== 'custom';
                    }
                });

                this.ui.dom.clearLogButton.addEventListener('click', () => this.clearCurrentSessionLogs());
                this.ui.dom.clearDebugLogButton.addEventListener('click', () => this.clearDebugLogs());
                this.ui.dom.clearAllLogsButton.addEventListener('click', () => this.clearAllData());
                this.ui.dom.sessionSelect.addEventListener('change', (e) => this.handleSessionChange(e));
                this.ui.dom.downloadLogButton.addEventListener('click', () => this.downloadSessionLog());
                
                this.ui.dom.lightboxCloseButton.addEventListener('click', () => this.ui.toggleModal('imageLightboxModal', false));
                this.ui.dom.imageLightboxModal.addEventListener('click', (e) => {
                    if (e.target === this.ui.dom.imageLightboxModal) {
                        this.ui.toggleModal('imageLightboxModal', false);
                    }
                });

                this.ui.dom.debugLogContainer.addEventListener('scroll', () => { this.userHasScrolledDebug = this.ui.dom.debugLogContainer.scrollTop > 0; });
                this.ui.dom.confirmModalCancel.addEventListener('click', () => this.ui.toggleModal('customConfirmModal', false));
            }

            handleMainAction() {
                this.startAudioContext();
                if (this.appState === 'monitoring') this.stopAllMonitoring();
                else this.openCameraSelectionModal();
            }

            async openCameraSelectionModal() {
                this.stopAllMonitoring();
                this.ui.dom.mainActionButton.disabled = true;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    stream.getTracks().forEach(track => track.stop());
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(d => d.kind === 'videoinput');
                    this.ui.populateCameraList(videoDevices);
                    this.ui.toggleModal('cameraSelectModal', true);
                } catch (err) {
                    this.ui.updateStatus(`카메라 접근 오류: ${err.message}`, 'error');
                } finally {
                    this.ui.dom.mainActionButton.disabled = false;
                }
            }

            async startSelectedMonitoring() {
                this.ui.toggleModal('cameraSelectModal', false);
                const selectedCheckboxes = Array.from(this.ui.dom.cameraList.querySelectorAll('input:checked'));
                if (selectedCheckboxes.length === 0) {
                    this.ui.updateStatus('선택된 카메라가 없습니다.', 'idle');
                    return;
                }

                const devicesToMonitor = selectedCheckboxes.map(cb => {
                    const deviceId = cb.dataset.deviceId;
                    const resSelect = this.ui.dom.cameraList.querySelector(`select[data-res-for="${deviceId}"]`);
                    return { deviceId, resolution: resSelect.value };
                });

                await this.createSession();
                this.setAppState('monitoring');
                this.ui.updateStatus(`${devicesToMonitor.length}개의 카메라를 모니터링합니다.`, 'success');
                this.ui.dom.blurLogTitle.textContent = '흐림 감지 로그 (현재 세션)';
                this.ui.dom.debugPanel.classList.toggle('hidden', !this.ui.dom.debugModeCheckbox.checked);
                this.ui.dom.cameraGrid.innerHTML = '';
                devicesToMonitor.forEach((device, index) => this.setupCamera(device, index === 0));
                this.applyOutputSize();
            }
            
            async setupCamera(device, isPrimary) {
                this.cameraAnalysisData.set(device.deviceId, { scores: [], average: 0, lastPosition: null, wasScoreLow: false });
                const card = this.ui.createCameraCard();
                this.ui.dom.cameraGrid.appendChild(card.wrapper);
                card.wrapper.dataset.device = JSON.stringify(device);
                card.wrapper.dataset.isPrimary = isPrimary;

                const constraints = { video: { deviceId: { exact: device.deviceId } } };
                if (device.resolution !== 'default') {
                    const [width, height] = device.resolution.split('x').map(Number);
                    constraints.video.width = { ideal: width };
                    constraints.video.height = { ideal: height };
                }
                this.addDebugLog('Requesting camera with constraints', 'INFO', constraints);

                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.activeStreams.push(stream);
                    card.video.srcObject = stream;
                    const deviceInfo = (await navigator.mediaDevices.enumerateDevices()).find(d => d.deviceId === device.deviceId);
                    card.nameEl.textContent = deviceInfo.label || `카메라 ${this.activeStreams.length}`;
                    card.captureButton.onclick = () => this.handleManualCapture(card);
                    card.video.onplaying = () => this.onMediaPlaying(card, device.deviceId, isPrimary);
                } catch (err) {
                    this.addDebugLog(`Failed to get stream for ${device.deviceId}`, 'ERROR', err);
                    this.handleAnalysisError(card);
                }
            }

            onMediaPlaying(card, deviceId, isPrimary) {
                this.addDebugLog(`Media started for ${deviceId}`);
                Object.assign(card.processCanvas, { width: card.video.videoWidth, height: card.video.videoHeight });
                Object.assign(card.overlayCanvas, { width: card.video.videoWidth, height: card.video.videoHeight });
                card.originalResolutionEl.textContent = `원본: ${card.video.videoWidth}x${card.video.videoHeight}`;
                this.startAnalysisLoop(card, deviceId, isPrimary);
            }

            stopAllMonitoring() {
                if (this.appState !== 'monitoring') return;
                this.activeStreams.forEach(s => s.getTracks().forEach(t => t.stop()));
                this.activeStreams = [];
                this.analysisLoops.forEach(id => cancelAnimationFrame(id));
                this.analysisLoops.clear();
                this.cameraAnalysisData.clear();
                this.ui.dom.cameraGrid.innerHTML = '';
                this.ui.dom.blurLogPanel.classList.add('hidden');
                this.currentSessionId = null;
                this.sessionLogEntries = [];
                this.setAppState('stopped');
                this.addDebugLog('All monitoring stopped.', 'SUCCESS');
            }
            
            startAnalysisLoop(card, deviceId, isPrimary) {
                const processCtx = card.processCanvas.getContext('2d', { willReadFrequently: true });
                let alertState = { active: false, lastAlertTime: 0 };
                const analysisData = this.cameraAnalysisData.get(deviceId);
                let lastClearFrame = { fullFrameUrl: null, croppedFaceUrl: null, score: 0 };
                const frameCaptureCanvas = document.createElement('canvas');

                const loop = () => {
                    if (!this.analysisLoops.has(deviceId)) return;
                    try {
                        if (!card.video.srcObject?.active || card.video.paused || card.video.videoWidth === 0) {
                            this.analysisLoops.delete(deviceId); return;
                        }
                        const detections = this.faceDetector.detectForVideo(card.video, performance.now()).detections;
                        const overlayCtx = card.overlayCanvas.getContext('2d');
                        overlayCtx.clearRect(0, 0, card.overlayCanvas.width, card.overlayCanvas.height);
                        
                        if (detections.length > 0) {
                            const mainFace = this.getCentermostFace(detections, card.video.videoWidth, card.video.videoHeight);
                            if (!mainFace) { analysisData.lastPosition = null; requestAnimationFrame(loop); return; }
                            const box = mainFace.boundingBox;
                            processCtx.drawImage(card.video, 0, 0, card.processCanvas.width, card.processCanvas.height);
                            const faceImageData = processCtx.getImageData(Math.max(0, box.originX), Math.max(0, box.originY), Math.min(card.processCanvas.width - box.originX, box.width), Math.min(card.processCanvas.height - box.originY, box.height));
                            const score = this.calculateFocusScore(faceImageData);
                            const currentCenter = { x: box.originX + box.width / 2, y: box.originY + box.height / 2 };
                            const movementDistance = analysisData.lastPosition ? Math.hypot(currentCenter.x - analysisData.lastPosition.x, currentCenter.y - analysisData.lastPosition.y) : 0;
                            analysisData.lastPosition = currentCenter;
                            const isStationary = movementDistance < 5.0;
                            let isScoreLow;
                            if (this.ui.dom.autoThresholdCheckbox.checked) {
                                analysisData.scores.push(score);
                                if (analysisData.scores.length > 50) analysisData.scores.shift();
                                const avg = analysisData.scores.length > 30 ? analysisData.scores.reduce((a, b) => a + b, 0) / analysisData.scores.length : 0;
                                isScoreLow = avg > 0 && score < avg * (parseFloat(this.ui.dom.sensitivityInput.value) / 100);
                                card.scoreEl.textContent = `${score.toFixed(1)} / ${avg.toFixed(1)}`;
                            } else {
                                isScoreLow = score < parseFloat(this.ui.dom.thresholdInput.value);
                                card.scoreEl.textContent = score.toFixed(1);
                            }
                            
                            const isBlurry = isScoreLow && !analysisData.wasScoreLow && isStationary;
                            analysisData.wasScoreLow = isScoreLow;

                            card.scoreEl.classList.toggle('text-red-500', isScoreLow);
                            
                            if (isBlurry) {
                                if (!alertState.active && (performance.now() - alertState.lastAlertTime > 1000)) {
                                    alertState = { active: true, lastAlertTime: performance.now() };
                                    card.wrapper.classList.add('alert');
                                    this.playAlertSound();
                                    if (isPrimary) this.captureAndLog(card.video, detections, mainFace, score, lastClearFrame, frameCaptureCanvas);
                                }
                            } else {
                                if (alertState.active) card.wrapper.classList.remove('alert');
                                alertState.active = false;
                            }
                            
                            lastClearFrame = {
                                fullFrameUrl: this.captureFrame(card.video, detections, frameCaptureCanvas, mainFace),
                                croppedFaceUrl: this.captureFrame(card.video, [mainFace], frameCaptureCanvas, mainFace, true),
                                score: score
                            };

                            this.drawDetections(overlayCtx, detections, mainFace, isBlurry, card.video);
                        } else {
                            card.scoreEl.textContent = '얼굴 미검출';
                            analysisData.lastPosition = null;
                        }
                        requestAnimationFrame(loop);
                    } catch (error) {
                        this.addDebugLog("Analysis loop error", "ERROR", error);
                        this.handleAnalysisError(card);
                    }
                };
                this.analysisLoops.set(deviceId, requestAnimationFrame(loop));
            }

            handleAnalysisError(card) {
                const deviceId = JSON.parse(card.wrapper.dataset.device).deviceId;
                this.analysisLoops.delete(deviceId);
                const errorOverlay = document.createElement('div');
                errorOverlay.className = 'absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center gap-2';
                errorOverlay.innerHTML = `<p class="text-yellow-400 font-bold">분석 오류, 2초 후 재시작합니다...</p>`;
                card.videoContainer.appendChild(errorOverlay);

                setTimeout(() => {
                    const device = JSON.parse(card.wrapper.dataset.device);
                    const isPrimary = card.wrapper.dataset.isPrimary === 'true';
                    card.wrapper.remove();
                    this.setupCamera(device, isPrimary);
                }, 2000);
            }
            
            handleManualCapture(card) {
                const video = card.video;
                if (!video.srcObject?.active || video.paused || video.videoWidth === 0) {
                    this.addDebugLog('Cannot capture, video not active.', 'WARN');
                    return;
                }
                const detections = this.faceDetector.detectForVideo(video, performance.now()).detections;
                if (detections.length === 0) {
                    alert('얼굴이 감지되지 않아 추출할 수 없습니다.');
                    return;
                }
                const mainFace = this.getCentermostFace(detections, video.videoWidth, video.videoHeight);
                if (!mainFace) return;

                const processCtx = card.processCanvas.getContext('2d');
                processCtx.drawImage(video, 0, 0, card.processCanvas.width, card.processCanvas.height);
                const box = mainFace.boundingBox;
                const faceImageData = processCtx.getImageData(Math.max(0, box.originX), Math.max(0, box.originY), Math.min(card.processCanvas.width - box.originX, box.width), Math.min(card.processCanvas.height - box.originY, box.height));
                const score = this.calculateFocusScore(faceImageData);
                
                const frameCaptureCanvas = document.createElement('canvas');
                this.saveBlurLog({
                    type: 'manual',
                    timestamp: new Date().toLocaleTimeString(),
                    blurryFrameUrl: this.captureFrame(video, detections, frameCaptureCanvas, mainFace),
                    croppedBlurryFaceUrl: this.captureFrame(video, [mainFace], frameCaptureCanvas, mainFace, true),
                    blurryScore: score,
                });
            }

            captureAndLog(video, detections, mainFace, score, lastClearFrame, canvas) {
                this.saveBlurLog({
                    timestamp: new Date().toLocaleTimeString(),
                    clearFrameUrl: lastClearFrame.fullFrameUrl,
                    blurryFrameUrl: this.captureFrame(video, detections, canvas, mainFace),
                    croppedClearFaceUrl: lastClearFrame.croppedFaceUrl,
                    croppedBlurryFaceUrl: this.captureFrame(video, [mainFace], canvas, mainFace, true),
                    clearScore: lastClearFrame.score,
                    blurryScore: score
                });
            }

            captureFrame(video, detections, canvas, mainFace = null, cropToFace = false) {
                const box = cropToFace && mainFace ? mainFace.boundingBox : { originX: 0, originY: 0, width: video.videoWidth, height: video.videoHeight };
                canvas.width = box.width;
                canvas.height = box.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, box.originX, box.originY, box.width, box.height, 0, 0, box.width, box.height);
                if (!cropToFace) this.drawDetections(ctx, detections, mainFace, !!mainFace, video);
                return canvas.toDataURL('image/jpeg', 0.8);
            }

            drawDetections(ctx, detections, mainFace, isBlurry, video) {
                const isCropped = ctx.canvas.width !== video.videoWidth || ctx.canvas.height !== video.videoHeight;
                detections.forEach(detection => {
                    const box = detection.boundingBox;
                    if (!box) return;
                    const isMain = detection === mainFace;
                    ctx.strokeStyle = isMain && isBlurry ? '#ef4444' : '#3b82f6';
                    ctx.lineWidth = isMain ? 4 : 2;
                    const offsetX = isCropped ? -box.originX : 0;
                    const offsetY = isCropped ? -box.originY : 0;
                    ctx.strokeRect(box.originX + offsetX, box.originY + offsetY, box.width, box.height);
                });
            }

            calculateFocusScore(imageData) {
                const { width, height, data } = imageData;
                if (width * height === 0) return 0;
                const gray = new Uint8Array(width * height);
                for (let i = 0; i < data.length; i += 4) gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                let variance = 0, count = 0;
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = y * width + x;
                        const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                        variance += laplacian * laplacian;
                        count++;
                    }
                }
                return count > 0 ? variance / count : 0;
            }

            getCentermostFace(detections, videoWidth, videoHeight) {
                if (!detections || detections.length < 2) return detections?.[0] || null;
                const center = { x: videoWidth / 2, y: videoHeight / 2 };
                return detections.reduce((closest, current) => {
                    const distA = Math.hypot(center.x - (closest.boundingBox.originX + closest.boundingBox.width / 2), center.y - (closest.boundingBox.originY + closest.boundingBox.height / 2));
                    const distB = Math.hypot(center.x - (current.boundingBox.originX + current.boundingBox.width / 2), center.y - (current.boundingBox.originY + current.boundingBox.height / 2));
                    return distB < distA ? current : closest;
                });
            }

            saveSettings() {
                const settings = {
                    autoThreshold: this.ui.dom.autoThresholdCheckbox.checked,
                    threshold: this.ui.dom.thresholdInput.value,
                    sensitivity: this.ui.dom.sensitivityInput.value,
                    mute: this.ui.dom.muteCheckbox.checked,
                    debug: this.ui.dom.debugModeCheckbox.checked,
                };
                localStorage.setItem(this.SETTINGS_KEY, JSON.stringify(settings));
            }

            loadSettings() {
                const settings = JSON.parse(localStorage.getItem(this.SETTINGS_KEY) || '{}');
                this.ui.dom.autoThresholdCheckbox.checked = settings.autoThreshold ?? false;
                this.ui.dom.thresholdInput.value = settings.threshold ?? 40;
                this.ui.dom.thresholdSlider.value = settings.threshold ?? 40;
                this.ui.dom.sensitivityInput.value = settings.sensitivity ?? 75;
                this.ui.dom.sensitivitySlider.value = settings.sensitivity ?? 75;
                this.ui.dom.muteCheckbox.checked = settings.mute ?? false;
                this.ui.dom.debugModeCheckbox.checked = settings.debug ?? true;
                this.ui.dom.debugPanel.classList.toggle('hidden', !this.ui.dom.debugModeCheckbox.checked);
            }

            applyOutputSize() {
                const selectedSize = this.ui.dom.modalOutputSizeControls.querySelector('input:checked').value;
                const customSize = this.ui.dom.customSizeInput.value;
                this.addDebugLog(`Applying output size. Selected: ${selectedSize}, Custom: ${customSize || 'N/A'}`);
                
                const sizeMap = { '480': '480px', '720': '720px', '1080': '1080px' };
                const maxHeight = sizeMap[selectedSize] || 'none';
                const maxWidth = selectedSize === 'custom' ? (customSize ? `${customSize}px` : 'none') : 'none';
                this.addDebugLog(`Calculated styles - maxWidth: ${maxWidth}, maxHeight: ${maxHeight}`);

                document.querySelectorAll('.camera-card').forEach(card => {
                    card.style.maxWidth = maxWidth;
                    const videoContainer = card.querySelector('.relative');
                    if (videoContainer) {
                        videoContainer.style.maxHeight = maxHeight;
                    }
                });
                this.addDebugLog(`Output size styles applied.`);
            }

            async createSession() {
                this.sessionLogEntries = [];
                if (!this.isDbAvailable) return;
                this.currentSessionId = Date.now();
                await this.dbManager.add('sessions', { id: this.currentSessionId, startTime: new Date().toLocaleString() });
                await this.loadSessions();
                this.ui.dom.sessionSelect.value = this.currentSessionId;
            }

            async saveBlurLog(logEntry) {
                const newEntry = { ...logEntry };
                if (this.isDbAvailable && this.currentSessionId) {
                    try {
                        const newId = await this.dbManager.add('blurLogs', { ...newEntry, sessionId: this.currentSessionId });
                        newEntry.id = newId;
                    } catch (error) {
                        this.addDebugLog('Failed to save log to DB.', 'ERROR', error);
                    }
                }
                this.sessionLogEntries.push(newEntry);
                this.ui.renderBlurLog(this.sessionLogEntries, (entry) => this.handleDeleteLog(entry));
            }

            async loadSessions() {
                if (!this.isDbAvailable) return;
                const sessions = await this.dbManager.getAll('sessions');
                const select = this.ui.dom.sessionSelect;
                select.innerHTML = '<option value="">세션 기록 선택...</option>';
                sessions.sort((a, b) => b.id - a.id).forEach(session => select.add(new Option(session.startTime, session.id)));
            }
            
            async handleSessionChange(e) {
                if (!this.isDbAvailable) return;
                const sessionId = e.target.value;
                if (sessionId) {
                    const sessionText = e.target.options[e.target.selectedIndex].text;
                    this.ui.dom.blurLogTitle.textContent = `흐림 감지 로그 (${sessionText})`;
                    this.sessionLogEntries = await this.dbManager.getAllFromIndex('blurLogs', 'sessionId', Number(sessionId));
                    this.ui.renderBlurLog(this.sessionLogEntries, (entry) => this.handleDeleteLog(entry));
                } else {
                    this.ui.dom.blurLogTitle.textContent = '흐림 감지 로그';
                    this.sessionLogEntries = [];
                    this.ui.renderBlurLog(this.sessionLogEntries, (entry) => this.handleDeleteLog(entry));
                }
            }
            
            async handleDeleteLog(entryToDelete) {
                const index = this.sessionLogEntries.findIndex(entry => entry === entryToDelete);
                if (index > -1) {
                    this.sessionLogEntries.splice(index, 1);
                    if (this.isDbAvailable && entryToDelete.id) {
                        await this.dbManager.delete('blurLogs', entryToDelete.id);
                        this.addDebugLog(`Deleted log entry with id: ${entryToDelete.id}`, 'INFO');
                    }
                    this.ui.renderBlurLog(this.sessionLogEntries, (entry) => this.handleDeleteLog(entry));
                }
            }

            async clearCurrentSessionLogs() {
                const selectedSessionId = this.ui.dom.sessionSelect.value;
                if (this.isDbAvailable && selectedSessionId) {
                    await this.dbManager.deleteFromIndex('blurLogs', 'sessionId', Number(selectedSessionId));
                }
                this.sessionLogEntries = [];
                this.ui.renderBlurLog(this.sessionLogEntries, (entry) => this.handleDeleteLog(entry));
            }

            clearAllData() {
                if (!this.isDbAvailable) return;
                this.ui.showConfirm('모든 기록 삭제', '모든 세션과 로그를 삭제하시겠습니까?', async () => {
                    await this.dbManager.clearStore('sessions');
                    await this.dbManager.clearStore('blurLogs');
                    await this.loadSessions();
                    this.ui.renderBlurLog([], (entry) => this.handleDeleteLog(entry));
                    this.addDebugLog('All data has been cleared.', 'WARN');
                });
            }
            
            downloadSessionLog() {
                if (this.sessionLogEntries.length === 0) { alert('다운로드할 로그가 없습니다.'); return; }
                const simplifiedLogs = this.sessionLogEntries.map(log => ({ timestamp: log.timestamp, clearScore: log.clearScore, blurryScore: log.blurryScore }));
                const blob = new Blob([JSON.stringify(simplifiedLogs, null, 2)], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = Object.assign(document.createElement('a'), { href: url, download: `focus_log_${new Date().toISOString()}.txt` });
                document.body.appendChild(a).click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            addDebugLog(message, level = 'INFO', data = null) {
                let processedData = null;
                if (data) {
                    if (data instanceof Error) {
                        processedData = JSON.stringify({ name: data.name, message: data.message, stack: data.stack?.split('\n').map(s => s.trim()) });
                    } else {
                        processedData = JSON.stringify(data);
                    }
                }
                const logEntry = { timestamp: new Date().toLocaleTimeString(), level, message, data: processedData };
                this.debugLogEntries.push(logEntry);
                if (this.debugLogEntries.length > this.MAX_DEBUG_LOGS) this.debugLogEntries.shift();
                this.renderDebugLog();
            }

            renderDebugLog() {
                if (!this.ui.dom.debugLogContainer) return;
                this.ui.dom.debugLogContainer.innerHTML = '';
                const colorMap = { 'SUCCESS': 'text-green-400', 'ERROR': 'text-red-400', 'WARN': 'text-yellow-400' };
                this.debugLogEntries.forEach(log => {
                    const pre = document.createElement('pre');
                    pre.className = `p-1 rounded ${colorMap[log.level] || 'text-gray-400'}`;
                    pre.textContent = `[${log.timestamp}][${log.level}] ${log.message}`;
                    if (log.data) pre.textContent += `\n  Data: ${log.data}`;
                    this.ui.dom.debugLogContainer.prepend(pre);
                });
                if (!this.userHasScrolledDebug) this.ui.dom.debugLogContainer.scrollTop = 0;
            }

            clearDebugLogs() {
                this.debugLogEntries = [];
                this.renderDebugLog();
            }

            startAudioContext() {
                if (!this.audioContextStarted && Tone.context.state !== 'running') {
                    Tone.start().catch(e => console.error("Could not start audio context", e));
                    this.audioContextStarted = true;
                }
            }

            playAlertSound() {
                if (this.ui.dom.muteCheckbox.checked) return;
                this.startAudioContext();
                this.synth.triggerAttackRelease("C5", "8n");
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new FocusMonitorApp();
        });
    </script>
</body>
</html>
